<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON VERSE: HYPER SNAKE (TOUCH EDITION)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            color: white;
            cursor: none; /* Cache le curseur sur PC, ok sur tactile */
            touch-action: none; /* CRUCIAL: Emp√™che le scroll/zoom sur iPad/Mobile */
            -webkit-user-select: none; /* Safari */
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 24px;
            letter-spacing: 2px;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-weight: 900;
            font-size: 42px;
            color: #0ff;
        }

        /* Bouton Boost Tactile */
        #mobile-controls {
            position: absolute;
            bottom: 40px;
            right: 40px;
            pointer-events: auto; /* Active les clics */
            z-index: 5;
            display: none; /* Masqu√© par d√©faut sur Desktop */
        }

        /* Afficher sur les appareils tactiles */
        @media (pointer: coarse) {
            #mobile-controls { display: block; }
            .controls { display: none !important; } /* Cacher les instructions clavier */
            body { cursor: auto; }
        }

        .boost-btn {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            border: 4px solid #0ff;
            color: #0ff;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 30px #0ff, inset 0 0 20px #0ff;
            backdrop-filter: blur(5px);
            transition: transform 0.1s, background 0.1s;
            -webkit-tap-highlight-color: transparent;
        }

        .boost-btn:active {
            background: rgba(0, 255, 255, 0.4);
            transform: scale(0.90);
            box-shadow: 0 0 50px #0ff;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            z-index: 10;
            transition: opacity 0.5s;
        }

        h1 {
            font-size: 80px;
            margin: 0;
            color: #fff;
            text-transform: uppercase;
            text-shadow: 
                0 0 10px #0ff,
                0 0 20px #0ff,
                0 0 40px #0ff,
                0 0 80px #f0f;
            animation: pulseTitle 2s infinite alternate;
            text-align: center;
        }

        p {
            font-size: 20px;
            color: #ccc;
            margin-top: 20px;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }

        .btn {
            margin-top: 50px;
            padding: 20px 60px; /* Plus gros pour le tactile */
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: bold;
            color: #050505;
            background: #0ff;
            border: none;
            cursor: pointer;
            box-shadow: 0 0 20px #0ff;
            transition: transform 0.1s, box-shadow 0.1s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:active {
            transform: scale(0.95);
            background: #0dd;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        @keyframes pulseTitle {
            0% { text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #f0f; }
            100% { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 80px #f0f, 0 0 100px #f0f; }
        }

        #game-over-screen {
            background: rgba(20, 0, 0, 0.7);
        }

        #final-score {
            font-size: 100px;
            color: #fff;
            text-shadow: 0 0 30px #0ff;
            margin: 20px 0;
        }

        .controls {
            display: flex;
            gap: 40px;
            margin-top: 40px;
            font-size: 14px;
            opacity: 0.8;
            color: #fff;
        }
        
        /* Instructions mobiles */
        .mobile-hint {
            display: none;
            margin-top: 20px;
            color: #0ff;
            font-size: 18px;
        }
        @media (pointer: coarse) {
            .mobile-hint { display: block; }
            h1 { font-size: 12vw; } /* Responsive title */
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box">
                <span class="stat-label">SCORE</span>
                <span class="stat-value" id="current-score">0</span>
            </div>
            
            <div class="stat-box">
                <span class="stat-label">TEMPS</span>
                <span class="stat-value" id="time-display" style="color:#fff; text-shadow: 0 0 10px #fff;">01:00</span>
            </div>

            <div class="stat-box">
                <span class="stat-label">BOOST</span>
                <span class="stat-value" id="boost-meter">100%</span>
            </div>
        </div>
        
        <!-- Contr√¥les Tactiles -->
        <div id="mobile-controls">
            <div class="boost-btn" id="touch-boost-btn">TURBO</div>
        </div>
    </div>

    <div id="start-screen">
        <h1>NEON VERSE</h1>
        <div class="controls">
            <p>MOUVEMENT : FL√àCHES<br>BOOST : ESPACE (DANGEREUX)</p>
        </div>
        <div class="mobile-hint">
            GLISSEZ POUR DIRIGER<br>BOUTON TURBO POUR ACC√âL√âRER
        </div>
        
        <button class="btn" id="start-btn">D√âMARRER</button>
        
        <div class="controls" style="margin-top: 20px;">
            <span>üîä Audio Reactif</span>
            <span>‚è± 60s Chrono</span>
            <span>ü©∏ Gore</span>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #ff0000; text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;">FATALITY</h1>
        <p>SCORE FINAL</p>
        <div id="final-score">0</div>
        <p>TEMPS DE SURVIE: <span id="final-time">00:00</span></p>
        <p class="controls" style="font-size:16px; margin-top:20px; color:#aaa;">APPUYEZ SUR ESPACE POUR REJOUER</p>
        <button class="btn" id="restart-btn" style="background:red; box-shadow:0 0 20px red; color:white;">REJOUER</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- CONSTANTES & CONFIG ---
        const GRID_SIZE = 25;
        const NEON_BLUE = '#00ffff';
        const NEON_PINK = '#ff00ff';
        const NEON_YELLOW = '#ffff00';
        const NEON_RED = '#ff0000';
        const NEON_GREEN = '#00ff00';
        const BLOOD_RED = '#8a0303'; 

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = 0.3; 
                this.isPlaying = false;
                this.nextNoteTime = 0;
                this.tempo = 120;
                this.beatCount = 0;
                this.scale = [220, 261.63, 293.66, 329.63, 392.00, 440, 523.25, 587.33];
            }

            start() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime;
                this.scheduler();
            }

            stop() {
                this.isPlaying = false;
            }

            scheduler() {
                if (!this.isPlaying) return;
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.playBeat(this.nextNoteTime);
                    this.playArpeggio(this.nextNoteTime);
                    const secondsPerBeat = 60.0 / this.tempo;
                    this.nextNoteTime += secondsPerBeat / 4; 
                    this.beatCount++;
                }
                requestAnimationFrame(() => this.scheduler());
            }

            playBeat(time) {
                if (this.beatCount % 4 === 0) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.frequency.setValueAtTime(150, time);
                    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                    gain.gain.setValueAtTime(1, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                    osc.start(time);
                    osc.stop(time + 0.5);
                }
                if (this.beatCount % 8 === 4) {
                    const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < output.length; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = noiseBuffer;
                    const noiseFilter = this.ctx.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 1000;
                    const noiseGain = this.ctx.createGain();
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(this.masterGain);
                    noiseGain.gain.setValueAtTime(0.5, time);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                    noise.start(time);
                }
            }

            playArpeggio(time) {
                if (Math.random() > 0.6) { 
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sawtooth';
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    const note = this.scale[Math.floor(Math.random() * this.scale.length)];
                    osc.frequency.setValueAtTime(note, time);
                    gain.gain.setValueAtTime(0.1, time);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                    osc.start(time);
                    osc.stop(time + 0.3);
                }
            }

            playEatSound() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1500, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            playCrashSound() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.8);
                gain.gain.setValueAtTime(1.0, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.8);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.8);
            }

            playGlassBreak() {
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 2000;
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }
        }

        // --- PARTICLE SYSTEM ---
        class Particle {
            constructor(x, y, color, speed, size, isBlood = false) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * size + 2;
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * speed;
                this.vx = Math.cos(angle) * velocity;
                this.vy = Math.sin(angle) * velocity;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.01;
                this.isBlood = isBlood;
                
                if (isBlood) {
                    this.decay = Math.random() * 0.01 + 0.005; 
                    this.gravity = 0.5;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.isBlood) {
                    this.vy += 0.2; 
                } else {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                }
                
                this.life -= this.decay;
                if (!this.isBlood) this.size *= 0.95;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                
                // Optimisation: Pas de shadowBlur sur les particules
                // Le mode "lighter" suffit √† les faire briller
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // --- NOUVEAU: ONDE DE CHOC ---
        class Shockwave {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = Math.max(window.innerWidth, window.innerHeight) / 2;
                this.alpha = 1;
                this.speed = 25; // Tr√®s rapide
            }
            update() {
                this.radius += this.speed;
                this.alpha -= 0.03;
            }
            draw(ctx) {
                if (this.alpha <= 0) return;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.lineWidth = 15 * this.alpha;
                ctx.stroke();
                ctx.restore();
            }
        }

        // --- VISUAL EFFECTS ---
        class Crack {
            constructor(x, y, angle, length, depth) {
                this.x = x;
                this.y = y;
                this.segments = [];
                this.generate(x, y, angle, length, depth);
            }

            generate(x, y, angle, length, depth) {
                if (depth <= 0) return;
                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;
                this.segments.push({x1: x, y1: y, x2: endX, y2: endY});
                const numBranches = Math.floor(Math.random() * 2) + 1;
                for(let i=0; i<numBranches; i++) {
                    const newAngle = angle + (Math.random() - 0.5) * 1.5;
                    const newLength = length * (0.6 + Math.random() * 0.4);
                    this.generate(endX, endY, newAngle, newLength, depth - 1);
                }
            }

            draw(ctx) {
                // Optimisation: Simulation de glow sans shadowBlur
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.2)'; // Glow fake
                ctx.beginPath();
                this.segments.forEach(seg => {
                    ctx.moveTo(seg.x1, seg.y1);
                    ctx.lineTo(seg.x2, seg.y2);
                });
                ctx.stroke();

                ctx.lineWidth = 1.5;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; // Coeur
                ctx.beginPath();
                this.segments.forEach(seg => {
                    ctx.moveTo(seg.x1, seg.y1);
                    ctx.lineTo(seg.x2, seg.y2);
                });
                ctx.stroke();
            }
        }

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();

                this.audio = new AudioEngine();
                
                this.snake = [];
                this.food = {};
                this.particles = [];
                this.bloodStains = []; 
                this.cracks = []; 
                this.shockwaves = []; // Tableau pour les ondes de choc
                this.gridOffset = 0;
                this.flashIntensity = 0; // Pour le flash d'√©cran
                
                this.score = 0;
                this.boost = 100;
                this.isBoosting = false;
                this.dir = {x: 1, y: 0};
                this.nextDir = {x: 1, y: 0};
                
                this.lastTime = 0;
                this.tickRate = 100;
                this.tickAccumulator = 0;
                
                this.shakeAmount = 0;
                this.running = false;
                
                // Timer (Compte √† rebours)
                this.timeLeft = 60000; // 60 secondes en ms

                window.addEventListener('resize', () => this.resize());
                this.setupInputs();
                
                this.loop = this.loop.bind(this);
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.cols = Math.floor(this.canvas.width / GRID_SIZE);
                this.rows = Math.floor(this.canvas.height / GRID_SIZE);
            }

            setupInputs() {
                // --- GESTION TACTILE (SWIPE) ---
                let touchStartX = 0;
                let touchStartY = 0;
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Stop scroll
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }, {passive: false});

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault(); // Stop scroll
                }, {passive: false});

                this.canvas.addEventListener('touchend', (e) => {
                    if (!this.running) return;

                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const diffX = touchEndX - touchStartX;
                    const diffY = touchEndY - touchStartY;
                    
                    // Seuil minimum pour √©viter les micro-mouvements
                    if (Math.abs(diffX) < 30 && Math.abs(diffY) < 30) return;

                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        // Horizontal
                        if (diffX > 0) {
                             if (this.dir.x === 0) this.nextDir = {x: 1, y: 0};
                        } else {
                             if (this.dir.x === 0) this.nextDir = {x: -1, y: 0};
                        }
                    } else {
                        // Vertical
                        if (diffY > 0) {
                             if (this.dir.y === 0) this.nextDir = {x: 0, y: 1};
                        } else {
                             if (this.dir.y === 0) this.nextDir = {x: 0, y: -1};
                        }
                    }
                });

                // --- BOUTON BOOST TACTILE ---
                const boostBtn = document.getElementById('touch-boost-btn');
                
                boostBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(this.running) this.isBoosting = true;
                }, {passive: false});
                
                boostBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.isBoosting = false;
                });
                
                // Pour la souris sur PC si on veut tester le bouton aussi
                boostBtn.addEventListener('mousedown', (e) => {
                    if(this.running) this.isBoosting = true;
                });
                boostBtn.addEventListener('mouseup', (e) => {
                    this.isBoosting = false;
                });

                // --- CLAVIER (Garder pour Desktop) ---
                window.addEventListener('keydown', (e) => {
                    // Gestion du red√©marrage avec Espace si Game Over
                    if (!this.running) {
                        const gameOverScreen = document.getElementById('game-over-screen');
                        if (!gameOverScreen.classList.contains('hidden') && e.code === 'Space') {
                            gameOverScreen.classList.add('hidden');
                            this.start();
                        }
                        return;
                    }

                    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space"].indexOf(e.code) > -1) {
                        e.preventDefault();
                    }
                    switch(e.code) {
                        case 'ArrowUp': if (this.dir.y === 0) this.nextDir = {x: 0, y: -1}; break;
                        case 'ArrowDown': if (this.dir.y === 0) this.nextDir = {x: 0, y: 1}; break;
                        case 'ArrowLeft': if (this.dir.x === 0) this.nextDir = {x: -1, y: 0}; break;
                        case 'ArrowRight': if (this.dir.x === 0) this.nextDir = {x: 1, y: 0}; break;
                        case 'Space': this.isBoosting = true; break;
                    }
                });
                window.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') this.isBoosting = false;
                });

                // --- BOUTONS UI ---
                document.getElementById('start-btn').addEventListener('click', () => {
                    document.getElementById('start-screen').classList.add('hidden');
                    this.start();
                });
                document.getElementById('restart-btn').addEventListener('click', () => {
                    document.getElementById('game-over-screen').classList.add('hidden');
                    this.start();
                });
            }

            updateTimer() {
                // Conversion en secondes pour affichage
                let secondsLeft = Math.ceil(this.timeLeft / 1000);
                if (secondsLeft < 0) secondsLeft = 0;

                const minutes = Math.floor(secondsLeft / 60);
                const seconds = secondsLeft % 60;
                
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                const display = document.getElementById('time-display');
                display.innerText = timeString;

                // Alerte rouge si moins de 10 secondes
                if (secondsLeft <= 10) {
                    display.style.color = '#ff0000';
                    display.style.textShadow = '0 0 15px #ff0000';
                } else {
                    display.style.color = '#fff';
                    display.style.textShadow = '0 0 10px #fff';
                }
                
                return timeString;
            }

            start() {
                this.running = true;
                this.snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
                this.dir = {x: 1, y: 0};
                this.nextDir = {x: 1, y: 0};
                this.score = 0;
                this.boost = 100;
                this.tickRate = 80;
                this.audio.start();
                this.spawnFood();
                this.particles = [];
                this.bloodStains = [];
                this.cracks = [];
                this.shockwaves = [];
                this.flashIntensity = 0;
                
                // Timer Init (60 secondes)
                this.timeLeft = 60000;
                this.updateTimer();
                
                requestAnimationFrame(this.loop);
            }

            createGore(x, y, isWallImpact) {
                const numStains = 15;
                for(let i=0; i<numStains; i++) {
                    this.bloodStains.push({
                        x: x + (Math.random() - 0.5) * GRID_SIZE * 4,
                        y: y + (Math.random() - 0.5) * GRID_SIZE * 4,
                        radius: Math.random() * GRID_SIZE + 5,
                        color: `rgba(139, 0, 0, ${Math.random() * 0.4 + 0.4})` 
                    });
                }
                
                // SANG
                for(let i=0; i<100; i++) {
                    this.particles.push(new Particle(x, y, BLOOD_RED, 20, 5, true));
                }

                if (isWallImpact) {
                    this.audio.playGlassBreak();
                    
                    // 1. Flash √âcran (White Out)
                    this.flashIntensity = 1.0;
                    
                    // 2. Onde de Choc
                    this.shockwaves.push(new Shockwave(x, y));

                    // 3. Fissures (Beaucoup plus denses)
                    const angleBase = Math.atan2(y - this.canvas.height/2, x - this.canvas.width/2);
                    for(let i=0; i<8; i++) {
                        this.cracks.push(new Crack(x, y, angleBase + Math.PI + (Math.random()-0.5), 500, 5));
                    }
                    
                    // 4. Eclats de verre (Particules blanches rapides)
                    for(let i=0; i<50; i++) {
                         this.particles.push(new Particle(x, y, '#ccffff', 35, 3));
                    }
                }
            }

            gameOver() {
                this.running = false;
                const finalTime = this.updateTimer(); // Affiche 00:00
                this.audio.playCrashSound();
                this.audio.stop();
                this.shakeAmount = 60; // Impact plus violent

                setTimeout(() => {
                    document.getElementById('game-over-screen').classList.remove('hidden');
                    document.getElementById('final-score').innerText = this.score;
                    document.getElementById('final-time').innerText = "Temps √©coul√© / Mort"; // Simplifi√©
                }, 1500);
            }

            spawnFood() {
                let valid = false;
                while (!valid) {
                    this.food = {
                        x: Math.floor(Math.random() * this.cols),
                        y: Math.floor(Math.random() * this.rows),
                        color: [NEON_PINK, NEON_YELLOW, NEON_GREEN][Math.floor(Math.random() * 3)]
                    };
                    valid = !this.snake.some(s => s.x === this.food.x && s.y === this.food.y);
                }
            }

            update(dt) {
                // Gestion du Flash
                if (this.flashIntensity > 0) {
                    this.flashIntensity -= 0.05;
                    if (this.flashIntensity < 0) this.flashIntensity = 0;
                }

                // Gestion du Compte √† Rebours
                if (this.running) {
                    this.timeLeft -= dt;
                    if (this.timeLeft <= 0) {
                        this.timeLeft = 0;
                        this.gameOver();
                        return; // Stop tout de suite
                    }
                    this.updateTimer();
                }

                if (this.isBoosting && this.boost > 0) {
                    this.boost -= 2;
                    this.currentTickRate = this.tickRate / 2.5;
                    const tail = this.snake[this.snake.length -1];
                    this.particles.push(new Particle(tail.x * GRID_SIZE, tail.y * GRID_SIZE, NEON_BLUE, 2, 4));
                } else {
                    this.currentTickRate = this.tickRate;
                    if (this.boost < 100) this.boost += 0.2;
                }

                this.tickAccumulator += dt;
                if (this.tickAccumulator > this.currentTickRate) {
                    this.tickAccumulator = 0;
                    this.move();
                }

                this.particles = this.particles.filter(p => p.life > 0 || p.isBlood && p.y < this.canvas.height);
                this.particles.forEach(p => p.update());
                
                // Update Shockwaves
                this.shockwaves = this.shockwaves.filter(s => s.alpha > 0);
                this.shockwaves.forEach(s => s.update());

                if (this.shakeAmount > 0) this.shakeAmount *= 0.9;
                if (this.shakeAmount < 0.5) this.shakeAmount = 0;

                document.getElementById('current-score').innerText = this.score;
                document.getElementById('boost-meter').innerText = Math.floor(this.boost) + '%';
                document.getElementById('boost-meter').style.color = this.boost < 20 ? 'red' : '#0ff';
            }

            move() {
                this.dir = this.nextDir;
                const head = {x: this.snake[0].x + this.dir.x, y: this.snake[0].y + this.dir.y};

                let impactX = head.x * GRID_SIZE + GRID_SIZE/2;
                let impactY = head.y * GRID_SIZE + GRID_SIZE/2;

                if (head.x < 0 || head.x >= this.cols || head.y < 0 || head.y >= this.rows) {
                    if (head.x < 0) impactX = 0;
                    if (head.x >= this.cols) impactX = this.canvas.width;
                    if (head.y < 0) impactY = 0;
                    if (head.y >= this.rows) impactY = this.canvas.height;

                    this.createGore(impactX, impactY, true);
                    this.gameOver();
                    return;
                }

                if (this.snake.some(s => s.x === head.x && s.y === head.y)) {
                    this.createGore(impactX, impactY, false);
                    this.gameOver();
                    return;
                }

                this.snake.unshift(head);

                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score += 100 + (this.isBoosting ? 50 : 0);
                    
                    // BONUS TEMPS: +1 seconde
                    this.timeLeft += 1000; 
                    
                    this.audio.playEatSound();
                    this.shakeAmount = 5;
                    for(let i=0; i<20; i++) {
                        this.particles.push(new Particle(impactX, impactY, this.food.color, 8, 5));
                    }
                    if (this.tickRate > 40) this.tickRate -= 1;
                    this.spawnFood();
                } else {
                    this.snake.pop();
                }
            }

            draw() {
                this.ctx.fillStyle = '#050505';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const shakeX = (Math.random() - 0.5) * this.shakeAmount;
                const shakeY = (Math.random() - 0.5) * this.shakeAmount;
                this.ctx.save();
                this.ctx.translate(shakeX, shakeY);

                // SANG
                this.bloodStains.forEach(stain => {
                    this.ctx.fillStyle = stain.color;
                    this.ctx.beginPath();
                    this.ctx.arc(stain.x, stain.y, stain.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // GRILLE
                this.gridOffset = (this.gridOffset + (this.isBoosting ? 4 : 1)) % GRID_SIZE;
                this.ctx.strokeStyle = 'rgba(255, 0, 255, 0.1)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for (let x = 0; x <= this.canvas.width; x += GRID_SIZE) {
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                }
                for (let y = this.gridOffset; y <= this.canvas.height; y += GRID_SIZE) {
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                }
                this.ctx.stroke();

                // NEON & PARTICULES (Mode Glow Optimis√©)
                // On garde 'lighter' mais on supprime shadowBlur
                this.ctx.globalCompositeOperation = 'lighter';
                
                // Dessin des particules sans shadowBlur
                this.ctx.shadowBlur = 0;
                this.particles.forEach(p => {
                    p.draw(this.ctx);
                });
                
                // Draw Shockwaves
                this.shockwaves.forEach(s => s.draw(this.ctx));

                // Food (Glow Simul√©)
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.2;
                const fx = this.food.x * GRID_SIZE + GRID_SIZE/2;
                const fy = this.food.y * GRID_SIZE + GRID_SIZE/2;

                // 1. Couche Glow (Grand cercle transparent)
                this.ctx.fillStyle = this.food.color; 
                this.ctx.globalAlpha = 0.4;
                this.ctx.beginPath();
                this.ctx.arc(fx, fy, (GRID_SIZE/2 + 8) * pulse, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 2. Couche Core (Petit cercle opaque)
                this.ctx.globalAlpha = 1.0;
                this.ctx.beginPath();
                this.ctx.arc(fx, fy, (GRID_SIZE/2 - 2) * pulse, 0, Math.PI * 2);
                this.ctx.fill();

                // --- SERPENT OPTIMIS√â (Glow Simul√©) ---
                // Plus de shadowBlur co√ªteux ici
                
                this.snake.forEach((s, i) => {
                    const x = s.x * GRID_SIZE;
                    const y = s.y * GRID_SIZE;
                    
                    const hue = (Date.now() / 10 - i * 5) % 360;
                    
                    // 1. Couche Glow (Carr√© plus grand, transparent)
                    this.ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.3)`;
                    this.ctx.fillRect(x - 2, y - 2, GRID_SIZE + 4, GRID_SIZE + 4);

                    // 2. Couche Core (Carr√© normal, opaque)
                    this.ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;

                    if (i === 0) {
                        this.ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                        // Yeux
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(x + GRID_SIZE*0.2, y + GRID_SIZE*0.2, 5, 5);
                        this.ctx.fillRect(x + GRID_SIZE*0.6, y + GRID_SIZE*0.2, 5, 5);
                    } else {
                        this.ctx.fillRect(x + 2, y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                    }
                });

                // CRACKS (Au dessus de tout)
                this.ctx.globalCompositeOperation = 'source-over';
                this.cracks.forEach(crack => crack.draw(this.ctx));

                this.ctx.restore();
                
                // --- FLASH D'√âCRAN (Overlay) ---
                if (this.flashIntensity > 0) {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${this.flashIntensity})`;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            loop(timestamp) {
                if (!this.running) {
                    if (this.shakeAmount > 0 || this.particles.length > 0 || this.shockwaves.length > 0) {
                        this.draw(); 
                        this.particles.forEach(p => p.update()); 
                        this.shockwaves.forEach(s => s.update());
                        if (this.shakeAmount > 0) this.shakeAmount *= 0.9;
                        if (this.flashIntensity > 0) this.flashIntensity -= 0.05;
                    }
                    requestAnimationFrame(this.loop);
                    return;
                }

                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;

                this.update(dt);
                this.draw();

                requestAnimationFrame(this.loop);
            }
        }

        const game = new Game();

    </script>
</body>
</html>
